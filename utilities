/**
 * Utility Functions - Helper functions for sheet manipulation, data parsing, and UI
 * This file should be loaded after config.gs
 */

// ===== SHEET MANIPULATION UTILITIES =====

/**
 * Safely get or create a sheet
 * @param {Spreadsheet} spreadsheet - The spreadsheet object
 * @param {string} sheetName - Name of the sheet to get or create
 * @return {Sheet} The sheet object
 */
function safeGetOrCreateSheet(spreadsheet, sheetName) {
  let sheet = spreadsheet.getSheetByName(sheetName);
  
  if (!sheet) {
    sheet = spreadsheet.insertSheet(sheetName);
  }
  
  return sheet;
}

/**
 * Safely remove filter from a sheet
 * @param {Sheet} sheet - The sheet to remove filter from
 */
function safeRemoveFilter(sheet) {
  try {
    const filter = sheet.getFilter();
    if (filter) {
      filter.remove();
    }
  } catch (e) {
    // Filter might not exist or already be removed
    console.log('No filter to remove or error removing filter:', e);
  }
}

/**
 * Create filter views for different sections of a summary sheet
 * @param {Sheet} sheet - The sheet to create filter views for
 * @param {Object} sectionRanges - Object containing section range information
 */
function createFilterViews(sheet, sectionRanges) {
  // Note: Filter views require Advanced Sheets API
  // This is a placeholder that creates basic filters instead
  console.log('Filter view creation requires Advanced Sheets API');
  
  // As a fallback, we can set up the sheet for easy filtering
  if (sectionRanges.loeSection) {
    // Could add named ranges for easy navigation
    try {
      const range = sheet.getRange(
        sectionRanges.loeSection.startRow,
        1,
        sectionRanges.loeSection.endRow - sectionRanges.loeSection.startRow + 1,
        sectionRanges.loeSection.numColumns
      );
      sheet.setNamedRange('LOE_SECTION', range);
    } catch (e) {
      console.log('Could not create named range:', e);
    }
  }
}

// ===== UI/PROGRESS UTILITIES =====

function showProgress(message) {
  const html = `
    <div style="padding: 20px;">
      <p style="font-family: Arial, sans-serif; font-size: 14px;">${message}</p>
      <div style="margin-top: 10px;">
        <div style="width: 100%; background-color: #f0f0f0; border-radius: 5px;">
          <div style="width: 0%; height: 20px; background-color: #4285f4; border-radius: 5px; 
                      animation: pulse 2s ease-in-out infinite;"></div>
        </div>
      </div>
    </div>
    <style>
      @keyframes pulse {
        0% { opacity: 0.6; }
        50% { opacity: 1; }
        100% { opacity: 0.6; }
      }
    </style>
  `;
  
  const htmlOutput = HtmlService
    .createHtmlOutput(html)
    .setWidth(400)
    .setHeight(120);
  
  progressDialog = SpreadsheetApp.getUi().showModelessDialog(htmlOutput, 'Processing...');
  console.log(message);
  Utilities.sleep(50);
}

function closeProgress() {
  const html = '<script>google.script.host.close();</script>';
  const htmlOutput = HtmlService
    .createHtmlOutput(html)
    .setWidth(1)
    .setHeight(1);
  
  SpreadsheetApp.getUi().showModelessDialog(htmlOutput, 'Closing...');
  Utilities.sleep(100);
}

function createProgressBar(sheet, row, column, percentage) {
  // Ensure percentage is a valid number
  percentage = parseInt(percentage) || 0;
  
  const barLength = 10;
  let filledBars, emptyBars;
  let displayText = '';
  
  if (percentage > 100) {
    // Overallocation - show full bar in red with percentage
    filledBars = barLength;
    emptyBars = 0;
    displayText = `${'â–ˆ'.repeat(filledBars)} ${percentage}%`;
  } else {
    // Normal case
    percentage = Math.max(0, Math.min(100, percentage));
    filledBars = Math.round(percentage / 10);
    emptyBars = barLength - filledBars;
    displayText = 'â–ˆ'.repeat(filledBars) + 'â–‘'.repeat(emptyBars);
  }
  
  // Set the value
  sheet.getRange(row, column).setValue(displayText);
  sheet.getRange(row, column).setFontFamily('Courier New');
  sheet.getRange(row, column).setFontSize(10);
  
  // Color based on percentage
  let color;
  if (percentage > 100) {
    color = '#ff0000'; // Bright red for overallocation
  } else if (percentage >= 80) {
    color = '#00a652'; // Green
  } else if (percentage >= 60) {
    color = '#fbbc04'; // Yellow
  } else {
    color = '#ea4335'; // Red
  }
  
  sheet.getRange(row, column).setFontColor(color);
}

// ===== CAPACITY UTILITIES =====

/**
 * Get capacity data for a specific team
 * @param {Spreadsheet} spreadsheet - The spreadsheet object
 * @param {string} teamName - Name of the team
 * @return {Object} Capacity data object with total and breakdown
 */
function getCapacityDataForTeam(spreadsheet, teamName) {
  const capacitySheet = spreadsheet.getSheetByName('Capacity');
  
  if (!capacitySheet) {
    console.log('Capacity sheet not found');
    return null;
  }
  
  // Get all data from capacity sheet
  const dataRange = capacitySheet.getDataRange();
  const values = dataRange.getValues();
  
  // Find the team row (case-insensitive)
  let teamRow = -1;
  for (let i = 0; i < values.length; i++) {
    if (values[i][0] && values[i][0].toString().toUpperCase() === teamName.toUpperCase()) {
      teamRow = i;
      break;
    }
  }
  
  if (teamRow === -1) {
    console.log(`Team ${teamName} not found in Capacity sheet`);
    return null;
  }
  
  // Get capacity values from columns B-E
  const capacityData = {
    feature: Number(values[teamRow][1]) || 0,      // Column B
    tech: Number(values[teamRow][2]) || 0,         // Column C
    klo: Number(values[teamRow][3]) || 0,          // Column D
    quality: Number(values[teamRow][4]) || 0,      // Column E
    total: 0
  };
  
  capacityData.total = capacityData.feature + capacityData.tech + capacityData.klo + capacityData.quality;
  
  return capacityData;
}

// ===== ALLOCATION UTILITIES =====

/**
 * Map allocation value to category for chart
 * @param {string} allocation - The allocation value
 * @return {string} The category name
 */
function mapAllocationToCategory(allocation) {
  if (!allocation) return 'Features (Product - Compliance & Feature)';
  
  const allocationLower = allocation.toLowerCase();
  
  if (allocationLower.includes('product') || allocationLower.includes('feature') || allocationLower.includes('compliance')) {
    return 'Features (Product - Compliance & Feature)';
  } else if (allocationLower.includes('tech') || allocationLower.includes('platform')) {
    return 'Tech / Platform';
  } else if (allocationLower.includes('klo')) {
    return 'Planned KLO';
  } else if (allocationLower.includes('quality')) {
    return 'Planned Quality';
  }
  
  // Default to Features if no match
  return 'Features (Product - Compliance & Feature)';
}

// ===== JIRA UTILITIES =====

/**
 * Apply JIRA hyperlinks to a column of keys
 * @param {Sheet} sheet - The sheet to apply hyperlinks to
 * @param {number} startRow - Starting row number
 * @param {number} column - Column number
 * @param {Array} keys - Array of JIRA keys
 */
function applyJiraHyperlinks(sheet, startRow, column, keys) {
  if (!keys || keys.length === 0) return;
  
  const formulas = keys.map(key => {
    if (!key) return [''];
    return [`=HYPERLINK("${JIRA_CONFIG.baseUrl}/browse/${key}","${key}")`];
  });
  
  const range = sheet.getRange(startRow, column, keys.length, 1);
  range.setFormulas(formulas);
}

// ===== FORMULA UTILITIES =====

/**
 * Force recalculation of all formulas in the spreadsheet
 */
function forceRecalculateAllFormulas() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = spreadsheet.getSheets();
  
  sheets.forEach(sheet => {
    const dataRange = sheet.getDataRange();
    const formulas = dataRange.getFormulas();
    
    // Find cells with formulas
    for (let row = 0; row < formulas.length; row++) {
      for (let col = 0; col < formulas[row].length; col++) {
        if (formulas[row][col]) {
          // Re-set the formula to force recalculation
          const range = sheet.getRange(row + 1, col + 1);
          range.setFormula(formulas[row][col]);
        }
      }
    }
  });
  
  SpreadsheetApp.flush();
}


/**
 * Clean up specific columns that commonly have JIRA objects
 */
function cleanupSpecificColumns() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSheet();
  
  // Get headers (assuming row 4)
  const headers = sheet.getRange(4, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Columns that typically have JIRA objects
  const targetColumns = [
    'Value Stream',
    'Org',
    'PI Commitment',
    'Program Increment',
    'Scrum Team',
    'Allocation',
    'Portfolio Initiative',
    'Program Initiative',
    'RAG',
    'Analyzed Value Stream',
    'Depends on Valuestream',
    'Depends on Team'
  ];
  
  // Find column indices
  const columnsToClean = [];
  headers.forEach((header, index) => {
    if (targetColumns.includes(header)) {
      columnsToClean.push({
        name: header,
        index: index + 1 // 1-based for Sheets
      });
    }
  });
  
  if (columnsToClean.length === 0) {
    ui.alert('No target columns found in this sheet.');
    return;
  }
  
  // Show confirmation
  const response = ui.alert(
    'Clean Specific Columns',
    `Found ${columnsToClean.length} columns to clean:\n${columnsToClean.map(c => c.name).join(', ')}\n\nContinue?`,
    ui.ButtonSet.YES_NO
  );
  
  if (response !== ui.Button.YES) return;
  
  try {
    showProgress('Cleaning specific columns...');
    
    let cleanedCount = 0;
    const lastRow = sheet.getLastRow();
    
    columnsToClean.forEach(column => {
      showProgress(`Cleaning column: ${column.name}...`);
      
      if (lastRow > 4) {
        const range = sheet.getRange(5, column.index, lastRow - 4, 1);
        const values = range.getValues();
        
        for (let i = 0; i < values.length; i++) {
          const cellValue = values[i][0];
          if (typeof cellValue === 'string' && cellValue.includes('{') && cellValue.includes('value=')) {
            const cleaned = parseSheetCellValue(cellValue);
            if (cleaned !== cellValue) {
              values[i][0] = cleaned;
              cleanedCount++;
            }
          }
        }
        
        range.setValues(values);
      }
    });
    
    closeProgress();
    ui.alert('Success', `Cleaned ${cleanedCount} cells across ${columnsToClean.length} columns.`, ui.ButtonSet.OK);
    
  } catch (error) {
    closeProgress();
    ui.alert('Error', 'Error cleaning columns: ' + error.toString(), ui.ButtonSet.OK);
  }
}

// Add these functions to the menu
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  const menu = ui.createMenu('ðŸ§¹ Data Cleanup');
  
  menu.addItem('Clean All Sheet Data', 'cleanupSheetData');
  menu.addItem('Clean Specific Columns', 'cleanupSpecificColumns');
  menu.addSeparator();
  
  // ... rest of your existing menu items ...
  
  menu.addToUi();
}
// ===== MAIN ANALYSIS FUNCTIONS (Referenced in menus) =====

/**
 * Setup function for initial configuration
 */
function setup() {
  const ui = SpreadsheetApp.getUi();
  ui.alert(
    'Setup Instructions',
    '1. Update JIRA_CONFIG in config.gs with your credentials\n' +
    '2. Update VALUE_STREAM_CONFIG as needed\n' +
    '3. Create a "Capacity" sheet with team capacity data\n' +
    '4. Use the menu to analyze PI data\n\n' +
    'For detailed instructions, see the documentation.',
    ui.ButtonSet.OK
  );
}
